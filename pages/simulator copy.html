<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>一歩進んだシミュレーション | Life×Money</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <link rel="stylesheet" href="../assets/simulator.css" />
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
  <!-- ▼ ヘッダー追加 ▼ -->
  <header>
    <div class="container nav">
      <a class="brand" href="/index.html">
        <span style="font-weight:700;font-size:1.2rem;color:var(--accent)">Life×Money</span>
      </a>
      <nav>
        <a class="btn ghost" href="/pages/founder.html">創設者の想い</a>
        <a class="btn ghost" href="/pages/simulator.html">シミュレーション</a>
        <a class="btn ghost" href="/pages/glossary.html">やさしい用語</a>
        <a class="btn ghost" href="/pages/faq.html">FAQ</a>
      </nav>
    </div>
  </header>

  <div class="wrap">
    <!-- ▼ ここから説明文を追加 ▼ -->
    <section class="muted" style="margin-bottom:1.5rem;">
      <h2 style="font-size:1.3rem;margin-bottom:.7rem;">一歩進んだシミュレーションについて</h2>
      <p>
        <b>「1分でわかる複利体験」では、元本・年率・年数を変えることで、複利の力で資産がどのように増えるかを直感的に体験できます。みなさん富裕層になるための条件は見いだせたでしょうか。</b>
        <br>
        しかし、実際の人生設計では、毎年の追加投資やインフレ、資産運用のリスク、目標とするインカム（配当・利息）など、より多くの要素を考慮する必要があります。
      </p>
      <p>
        <b>この「一歩進んだシミュレーション」ページでは、複数の運用モードや詳細なパラメータを設定し、資産とインカムの推移をより現実的にシミュレーションできます。</b>
        <br>
        目標達成までの道筋やリスクの幅、インフレ調整後の実質的な資産価値など、あなた自身のライフデザインに役立つ具体的な気づきを得ることができます。
      </p>
      <p>
        <b>「複利体験」で感じた資産形成の可能性を、さらに深く・具体的に掘り下げてみましょう。</b>
      </p>
    </section>
    <!-- ▲ ここまで説明文を追加 ▲ -->

    <h1>一歩進んだシミュレーション</h1>
    <p class="muted">中央値（期待値）・ワースト（5%）・ベスト（95%）の三本線で、資産とインカムの軌道を可視化します。</p>

    <!-- ▼ 説明：並行モード -->
    <div class="callout">
      <h3>並行モード（比率指定）とは？</h3>
      <div class="desc">
        Growth（値上がり狙い）と Income（配当・利息狙い）を <b>固定の比率</b>で同時運用する基本形です。<br>
        <b>毎年の追加投資</b>も同じ比率で配分し、<b>リバランスON</b>なら年末に元の比率へ揃えます。
      </div>
      <ul class="tips">
        <li>式（概念）：<br>
          <code>Gₜ = (Gₜ₋₁ + 追加×比率) × (1 + r<sub>G</sub>)</code>，<br>
          <code>Iₜ = (Iₜ₋₁ + 追加×(1-比率)) × (1 + r<sub>I</sub>)</code>，<br>
          総資産 <code>Aₜ = Gₜ + Iₜ</code>，インカム <code>CFₜ = Iₜ × r<sub>I</sub></code></li>
        <li>向いている人：<b>着実に増やしつつ配当も欲しい</b>、扱いをシンプルにしたい。</li>
        <li>パラメータ：Growth比率・毎年リバランス・Growth/Income の年率・σ・インフレ。</li>
      </ul>
    </div>

    <!-- ▼ 説明：二段ロケット -->
    <details class="guide" open>
      <summary><b class="badge">STEP 2</b>二段ロケット（全額切替）とは？</summary>
      <div class="desc" style="margin-top:8px;">
        最初は<b>全力でGrowth</b>に寄せて資産を膨らませ、<b>指定年数（Growthフェーズ）</b>が終わったら<b>資産をまるごとIncomeへ切替</b>してインカム重視に移行する戦略です。
      </div>
      <ul class="tips">
        <li>式（概念）：<br>
          フェーズ1（<code>y ≤ Y<sub>G</sub></code>）<code>Aₜ = (Aₜ₋₁ + 追加) × (1 + r<sub>G</sub>)</code>，<b>CF=0</b><br>
          フェーズ2（切替後）<code>Aₜ = (Aₜ₋₁ + 追加) × (1 + r<sub>I</sub>)</code>，<code>CFₜ = Aₜ × r<sub>I</sub></code>
        </li>
        <li>向いている人：<b>目標までの到達スピードを優先</b>し、その後は安定キャッシュを取りに行きたい。</li>
        <li>パラメータ：Growthフェーズ年数（切替タイミング）。</li>
      </ul>
    </details>


    <!-- KPI -->
    <div class="kpis" id="kpis">
      <div class="kpi"><b>必要元本（目標/利回り）</b><span id="kpi-required">—</span></div>
      <div class="kpi"><b>目標インカム到達年</b><span id="kpi-year">—</span></div>
      <div class="kpi"><b>最終年資産（期待値）</b><span id="kpi-assets">—</span></div>
      <div class="kpi"><b>最終年インカム（期待値）</b><span id="kpi-income">—</span></div>
    </div>

    <div class="grid">
      <!-- Controls -->
      <div class="card">
        <div class="section-title">モード選択</div>
        <div class="mode" id="mode">
          <label><input type="radio" name="mode" value="parallel" checked><span>並行モード（比率指定）</span></label>
          <label><input type="radio" name="mode" value="rocket"><span>二段ロケット（全額切替）</span></label>
        </div>

        <div class="section-title">基本パラメータ</div>
        <div class="row"><label>初期資産（円）<span class="help" title="いま手元にある投資可能な資産。">?</span></label><div class="dual" data-key="initial" data-type="int" data-min="0" data-max="2000000000" data-step="1000000"></div></div>
        <div class="row"><label>毎年の追加投資（円/年）<span class="help" title="給与などから毎年投資に回す金額。">?</span></label><div class="dual" data-key="contrib" data-type="int" data-min="0" data-max="50000000" data-step="100000"></div></div>
        <div class="row"><label>目標インカム（円/年）<span class="help" title="利息・配当だけで得たい年間キャッシュフロー。">?</span></label><div class="dual" data-key="target" data-type="int" data-min="0" data-max="50000000" data-step="100000"></div></div>

        <div class="section-title">運用パラメータ</div>
        <div class="row small"><label>Growth期待リターン（%/年）</label><div class="dual" data-key="gret" data-type="float" data-min="-20" data-max="30" data-step="0.5"></div></div>
        <div class="row small"><label>Income利回り（%/年）</label><div class="dual" data-key="iret" data-type="float" data-min="0" data-max="12" data-step="0.1"></div></div>
        <div class="row small"><label>インフレ率（%/年）</label><div class="dual" data-key="infl" data-type="float" data-min="0" data-max="5" data-step="0.1"></div></div>

        <div class="section-title">並行モード設定</div>
        <div class="row small"><label>Growth比率（%）</label><div class="dual" data-key="pgw" data-type="float" data-min="0" data-max="100" data-step="5"></div></div>
        <div class="row"><label></label><label><input id="rebalance" type="checkbox" checked> 毎年リバランス（比率維持）</label></div>

        <div class="section-title">ロケット設定</div>
        <div class="row small"><label>Growthフェーズ年数</label><div class="dual" data-key="gy" data-type="int" data-min="0" data-max="20" data-step="1"></div></div>

        <div class="section-title">期間・ボラティリティ</div>
        <div class="row small"><label>シミュレーション年数（年）</label><div class="dual" data-key="years" data-type="int" data-min="5" data-max="40" data-step="1"></div></div>
        <div class="row small"><label>Growth σ（%/年）</label><div class="dual" data-key="sg" data-type="float" data-min="0" data-max="60" data-step="1"></div></div>
        <div class="row small"><label>Income σ（%/年）</label><div class="dual" data-key="si" data-type="float" data-min="0" data-max="40" data-step="1"></div></div>
        <div class="row small"><label>モンテカルロ：パス数</label><div class="dual" data-key="paths" data-type="int" data-min="100" data-max="5000" data-step="100"></div></div>
        <div class="row small"><label>乱数シード</label><div class="dual" data-key="seed" data-type="int" data-min="1" data-max="10000" data-step="1"></div></div>

        <div class="row"><label></label><label><input id="showReal" type="checkbox"> 実質（インフレ調整）で表示</label></div>
      </div>

      <!-- Charts -->
      <div class="card">
        <div class="section-title">資産の推移（三本線）</div>
        <canvas id="assetsChart" height="220"></canvas>
        <div class="section-title" style="margin-top:18px;">インカムの推移（三本線）</div>
        <canvas id="incomeChart" height="220"></canvas>
        <p class="muted" style="margin-top:10px;">中央線＝期待値、上＝95%ベスト、下＝5%ワースト。教育目的の簡易モデル（年次正規リターン）です。</p>
      </div>
    </div>
  </div>

  <!-- ▼ フッター追加 ▼ -->
  <footer>
    <div class="container">
      <p>© <span id="y"></span> Life×Money — 金融リテラシー×ライフデザイン</p>
    </div>
  </footer>

<script>
/* ========== 初期状態 ========== */
const state = {
  mode:'parallel',
  initial:40000000,
  contrib:2000000,
  target:5000000,
  gret:8.0, iret:6.0, infl:1.0,
  pgw:70.0, rebalance:true,
  gy:5, years:20,
  sg:18.0, si:8.0, paths:1000, seed:42,
  showReal:false,
};
const $ = (q)=>document.querySelector(q);
let assetsChart, incomeChart;

/* ========== RNG & Normal ========== */
function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^(t>>>15),t|1); t^=t+Math.imul(t^(t>>>7),t|61); return ((t^(t>>>14))>>>0)/4294967296; }; }
function randn(rng){ let u=0,v=0; while(u===0)u=rng(); while(v===0)v=rng(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }

/* ========== Dual input (再入防止つき) ========== */
function buildDual(el, value){
  const type = el.dataset.type;
  const min  = parseFloat(el.dataset.min);
  const max  = parseFloat(el.dataset.max);
  const step = parseFloat(el.dataset.step);
  const key  = el.dataset.key;

  const r = document.createElement('input');
  r.type='range'; r.min=min; r.max=max; r.step=step; r.value=value;
  const n = document.createElement('input');
  n.type='number'; n.min=min; n.max=max; n.step=step; n.value=value;

  let syncing=false;
  const clamp = (v)=>{ v=(type==='int')?parseInt(v||0,10):parseFloat(v||0); if(isNaN(v)) v=0; return Math.max(min,Math.min(max,v)); };
  const sync = (src,dst)=>{ if(syncing) return; syncing=true; const v=clamp(src.value); if(src.value!==String(v)) src.value=v; if(dst.value!==String(v)) dst.value=v; state[key]=(type==='int')?parseInt(v,10):parseFloat(v); queueUpdate(); syncing=false; };

  r.addEventListener('input',()=>sync(r,n));
  n.addEventListener('input',()=>sync(n,r));

  el.appendChild(r); el.appendChild(n);
}

/* ========== 核心ロジック ========== */
function simulateDeterministic(p){
  const years=[], A=[], I=[];
  let assets=p.initial_assets, gw=p.parallel_growth_weight, iw=1-gw;
  let gAsset=assets*gw, iAsset=assets*iw;
  for(let y=1;y<=p.max_years;y++){
    years.push(y);
    if(p.mode==='rocket'){
      const g=(y<=p.growth_years), r=g?p.growth_return:p.income_return, start=assets+p.annual_contribution;
      assets=start*(1+r); A.push(assets); I.push(g?0:start*p.income_return);
    }else{
      const gC=p.annual_contribution*gw, iC=p.annual_contribution*iw;
      gAsset=(gAsset+gC)*(1+p.growth_return); iAsset=(iAsset+iC)*(1+p.income_return);
      const total=gAsset+iAsset; if(p.rebalance){ gAsset=total*gw; iAsset=total*iw; }
      A.push(total); I.push(iAsset*p.income_return);
    }
  }
  return {years, assets:A, income:I};
}

function simulateMonteCarlo(p, sigmaG, sigmaI, paths, seed){
  const yrs=p.max_years, rng=mulberry32(seed);
  const A=Array.from({length:yrs},()=>[]), Inc=Array.from({length:yrs},()=>[]);
  for(let k=0;k<paths;k++){
    if(p.mode==='rocket'){
      let assets=p.initial_assets;
      for(let y=1;y<=yrs;y++){
        const g=(y<=p.growth_years), mu=g?p.growth_return:p.income_return, sg=g?sigmaG:sigmaI, r=mu+randn(rng)*sg;
        const start=assets+p.annual_contribution; assets=start*(1+r);
        A[y-1].push(assets); Inc[y-1].push(g?0:start*p.income_return);
      }
    }else{
      let gw=p.parallel_growth_weight, iw=1-gw, gAsset=p.initial_assets*gw, iAsset=p.initial_assets*iw;
      for(let y=1;y<=yrs;y++){
        const rG=p.growth_return+randn(rng)*sigmaG, rI=p.income_return+randn(rng)*sigmaI;
        gAsset=(gAsset+p.annual_contribution*gw)*(1+rG);
        iAsset=(iAsset+p.annual_contribution*iw)*(1+rI);
        const total=gAsset+iAsset; if(p.rebalance){ gAsset=total*gw; iAsset=total*iw; }
        A[y-1].push(total); Inc[y-1].push(iAsset*p.income_return);
      }
    }
  }
  const pct=(arr,q)=>{ const s=[...arr].sort((a,b)=>a-b); const i=Math.max(0,Math.min(s.length-1,Math.floor(q/100*(s.length-1)))); return s[i]; };
  const medA=[],p05A=[],p95A=[],medI=[],p05I=[],p95I=[];
  for(let y=0;y<yrs;y++){ medA.push(pct(A[y],50)); p05A.push(pct(A[y],5)); p95A.push(pct(A[y],95)); medI.push(pct(Inc[y],50)); p05I.push(pct(Inc[y],5)); p95I.push(pct(Inc[y],95)); }
  return {medA,p05A,p95A,medI,p05I,p95I};
}

/* ========== チャート ========== */
function buildCharts(){
  const base={ responsive:true, maintainAspectRatio:false, animation:false,
    scales:{ y:{ ticks:{ callback:(v)=>v.toLocaleString('ja-JP') } } } };
  assetsChart=new Chart(document.getElementById('assetsChart'),{ type:'line', data:{labels:[],datasets:[]}, options:base });
  incomeChart=new Chart(document.getElementById('incomeChart'),{ type:'line', data:{labels:[],datasets:[]}, options:base });
}

function setDatasets(chart, mid, low, high){
  chart.data.datasets = [
    {label:'期待値（中央）', data:mid, borderWidth:2, tension:.15 },
    {label:'5% ワースト',   data:low, borderWidth:1.5, borderDash:[6,4], tension:.15 },
    {label:'95% ベスト',    data:high, borderWidth:1.5, borderDash:[6,4], tension:.15 },
  ];
  chart.update();
}

/* ========== 更新処理（デバウンス付き） ========== */
function updateAll(){
  const p = {
    initial_assets: state.initial,
    annual_contribution: state.contrib,
    target_income: state.target,
    growth_years: state.gy,
    growth_return: state.gret/100,
    income_return: state.iret/100,
    inflation: state.infl/100,
    max_years: state.years,
    mode: state.mode,
    parallel_growth_weight: state.pgw/100,
    rebalance: state.rebalance
  };

  const det = simulateDeterministic(p);
  const mc  = simulateMonteCarlo(p, state.sg/100, state.si/100, state.paths, state.seed);

  // KPI
  const req=(p.target_income/Math.max(p.income_return,1e-9));
  $('#kpi-required').textContent = `${Math.round(req).toLocaleString('ja-JP')} 円`;
  const hit = det.income.findIndex(v=>v>=p.target_income);
  $('#kpi-year').textContent = (hit>=0)? `Year ${hit+1}` : '—';
  $('#kpi-assets').textContent = `${Math.round(det.assets.at(-1)).toLocaleString('ja-JP')} 円`;
  $('#kpi-income').textContent = `${Math.round(det.income.at(-1)).toLocaleString('ja-JP')} 円`;

  // ラベル
  const labels = det.years.map(y=>`Y${y}`);
  assetsChart.data.labels = labels;
  incomeChart.data.labels = labels;

  // 実質表示
  const toReal = (arr)=>arr.map((v,i)=> v / Math.pow(1+p.inflation, i));
  const midA = state.showReal ? toReal(det.assets) : det.assets;
  const midI = state.showReal ? toReal(det.income) : det.income;
  const lowA = state.showReal ? toReal(mc.p05A) : mc.p05A;
  const higA = state.showReal ? toReal(mc.p95A) : mc.p95A;
  const lowI = state.showReal ? toReal(mc.p05I) : mc.p05I;
  const higI = state.showReal ? toReal(mc.p95I) : mc.p95I;

  setDatasets(assetsChart, midA, lowA, higA);
  setDatasets(incomeChart, midI, lowI, higI);
}
function queueUpdate(){ clearTimeout(queueUpdate.t); queueUpdate.t=setTimeout(updateAll, 50); }

/* ========== 配線 & 初期化 ========== */
window.addEventListener('DOMContentLoaded', ()=>{
  // dual inputs
  document.querySelectorAll('.dual').forEach(el=> buildDual(el, state[el.dataset.key]) );

  // mode
  document.querySelectorAll('input[name="mode"]').forEach(r=>{
    r.addEventListener('change', e=>{ state.mode=e.target.value; queueUpdate(); });
  });
  // toggles
  $('#rebalance').addEventListener('change', e=>{ state.rebalance=e.target.checked; queueUpdate(); });
  $('#showReal').addEventListener('change', e=>{ state.showReal=e.target.checked; queueUpdate(); });

  // charts once
  buildCharts();
  updateAll();
});
</script>
<script src="../assets/simulator.js"></script>

</body>
</html>
